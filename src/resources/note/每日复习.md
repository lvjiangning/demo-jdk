# 算法相关

## 算法复杂度

常数阶O(1)   : 常数计算，循环条件边界是常数也是O（1）

对数阶O(logN) 

线性阶O(n) 

线性对数阶O(nlogN) 

平方阶O(n²) 

立方阶O(n³) 

K次方阶O(n^k) 

指数阶(2^n) 

**上面从上至下依次的时间复杂度越来越大，执行的效率越来越低**

## 位运算

| 符号 | 描述       | 运算规则                                                     |
| :--- | :--------- | :----------------------------------------------------------- |
| &    | 与         | 两数都为1 则 1 ，否则0                                       |
| \|   | 或         | 参加运算的两个数中的一个为1，结果就为1。                     |
| ^    | 异或       | 两个相应位值**不同**，则该位结果为1，否则为0，可以记做 **无进位相加**； |
| ~    | 取反       | 0变1，1变0                                                   |
| <<   | 左移       | 各二进位全部左移若干位，高位丢弃，低位补0, a >> 1 相当于a*2  |
| >>   | 右移       | 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） |
| \>>> | 无符号右移 | 无符号右移，忽略符号位，空位都以0补齐                        |

```
&=        例：a&=b    相当于     a=a&b

|=        例：a|=b    相当于     a=a|b

>>=      例：a>>=b   相当于     a=a>>b

<<=      例：a<<=b     相当于      a=a<<b

^=        例：a^=b    相当于   a=a^b

结论：-1的二进制表示形式是【11111111111111111111111111111111】
=============================
结论：int类型的最小数【-2147483648】的二进制表现【10000000000000000000000000000000】
=============================
结论：int类型的最大数【2147483647】的二进制表现【01111111111111111111111111111111】
=============================
结论：正整数n的负数等于 ~n+1
=============================
结论：负整数n的正整数等于n的绝对值-1
=============================
-2147483648
-2147483648
结论：Integer.MIN_VALUE 取反+1 等于自己
=============================
```

# 常用java代码

## compareTo

return s1.age > s2.age ? 1 : -1;的返回值为1时，也就是说 s1的值大于s2的值时 ，compareTo是按照升序（由小到大）排序的！