# 位运算

## 参考

> https://blog.csdn.net/morewindows/article/details/7354571

## 位运算概览

| 符号 | 描述 | 运算规则                                                     |
| :--- | :--- | :----------------------------------------------------------- |
| &    | 与   | 两个位都为1时，结果才为1                                     |
| \|   | 或   | 两个位都为0时，结果才为0                                     |
| ^    | 异或 | 两个位相同为0，相异为1                                       |
| ~    | 取反 | 0变1，1变0                                                   |
| <<   | 左移 | 各二进位全部左移若干位，高位丢弃，低位补0, a >> 1 相当于a*2  |
| >>   | 右移 | 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） |
|      |      |                                                              |

```
&=        例：a&=b    相当于     a=a&b

|=        例：a|=b    相当于     a=a|b

>>=      例：a>>=b   相当于     a=a>>b

<<=      例：a<<=b     相当于      a=a<<b

^=        例：a^=b    相当于   a=a^b
```

## 打印int类型二进制



```java
 public static void print(int num) {
        for (int i = 31; i >= 0; i--) {
            // $ 与运算，两数对比 如果两数为1则为1，其他情况则为0,1 << i 表示左移1位
            System.out.print((num & (1 << i)) == 0 ? "0" : "1");
        }
        System.out.println();
    }
```



## 原码、反码、补码

**原码**：比如12的原码（在八位机中）是，0000 1100，（-8）的原码是，1000 1000，其中首位是符号位，0代表正数，首位1代表的是负数。

**反码**：正数的反码是其本身；负数的反码是保留符号位不变，其他位取反。（-8）的反码是1111 0111。取反操作指：原为1，得0；原为0，得1。（1变0; 0变1）

> 比如：将00000000 00000000 00000000 00000101每一位取反，得11111111 11111111 11111111 11111010。
>
> 称：11111111 11111111 11111111 11111010 是 00000000 00000000 00000000 00000101 的反码。
>
> 反码是相互的，所以也可称：
>
> 11111111 11111111 11111111 11111010 和 00000000 00000000 00000000 00000101 互为反码。

**补码**：正数的补码是其本身；负数的补码是在反码的基础上加1。（-8）的补码是 1111 1000.

> 也就是说，要得到一个数的补码，先得到反码，然后将反码加上1，所得数称为补码。
>
> 比如：00000000 00000000 00000000 00000101 的反码是：11111111 11111111 11111111 11111010。
>
> 那么，补码为：
>
> 11111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011

整数在计算机中，是以 ***补码*** 形式存储的。

**在计算机中，负数以其正值的补码形式表达**。


再举一例，我们来看整数-1在计算机中如何表示。

假设这也是一个int类型，那么：


1、先取1的原码：00000000 00000000 00000000 00000001

2、得反码：   11111111 11111111 11111111 11111110

3、得补码：   11111111 11111111 11111111 11111111


可见，－1在计算机里用二进制表达就是全1



## Int类型的二进制表现

首先这是针对int占4个字节的情况。
最高位是符号位，1表示是负数，0表示是非负数。
0111 1111 1111 1111，这是int_max，可能我们就会想为什么最小值不是-int_max呢？
因为计算机是以补码的形式来存储数字的，不管-0还是+0，补码都是0000 0000 0000 0000，
这就造成了没有任何一个数的补码是1000 0000 0000 0000，所以就可以把这个补码用来存储一个数（不要浪费资源嘛），就规定用它来存储-(int_max+1)，所以int最小值是-2147483648，即 1000 0000 0000 0000。

【拓展】：
因此我们也发现，2147483647 + 1会溢出变成-2147483648
因为2147483647 补码是：0111 1111 1111 1111 1111 1111 1111 1111
加1之后补码就变成了：1000 0000 0000 0000 0000 0000 0000 0000
这正好就是-2147483648的补码

所以在int中用于正数表示的有31位，能表示的数就是2^31 = 2147483648个
加上0之后的话，最大值就只能到2147483647

同理负数也有31位的空间去表示
只能表示2147483648这么多个数，因为-0不需要表示，所以负数就多出一个数可以表示
就用这个多出来的表示-2147483648

所以java中int能表示的最大值就是2147483647
能表示的最小值是-2147483648






## 加、减、乘、除

> 代码路径：com.lv.algorithm.greenhand.Code18_BitAddMinusMultiDiv







# 

